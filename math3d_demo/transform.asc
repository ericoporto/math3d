// new module script

Matrix* r1;
Matrix* r2;
Matrix* r3;

Transform* tT;
Transform* tS;
Transform* tR;

Transform* Transform::Set(int row, int column, float value){
  if(row>=0 && row<this.row_count &&
     column>=0 && column<this.column_count) {

    this.v[row*this.column_count+column] = value;

    return this;
  }
}

float Transform::Get(int row, int column){
  return this.v[row*this.column_count+column];
}

static Transform* Transform::Create(){
  Transform* m = new Transform;

  m.row_count = 4;
  m.column_count = 4;
  m.cell_count = 16;

  for(int i=0; i<m.row_count; i++){
    for(int j=0; j<m.column_count; j++){
      if(i==j){
        m.Set(i, j, 1.0);
      } else {
        m.Set(i, j, 0.0);
      }
    }
  }

  return m;
}

static Transform* Transform::CreateFromString(String s){
  if(s == null) return null;
  if(s.Length<=3) return null;
  if(!(s.StartsWith("{") && s.EndsWith("}"))) return null;

  s = s.Replace("{","");
  s = s.Substring(0, s.Length-2);

  String s1[]=s.Split("},");

  int row_count=0;
  while(s1[row_count] != null) row_count++;

  s = s.Replace("}","");
  s = s.Replace(" ","");

  String s2[]=s.Split(",");

  int cell_count=0;
  while(s2[cell_count] != null) cell_count++;

  int column_count = cell_count/row_count;

  Transform* m = new Transform;

  m.row_count = row_count;
  m.column_count = column_count;
  m.cell_count = cell_count;

  //Display("rc=%d [cc=%d [cells=%d[", row_count, column_count, cell_count);

  for(int i=0; i<m.row_count; i++){
    for(int j=0; j<m.column_count; j++){
      //Display("i=%d, j=%d", i, j);
      //Display("%s[[ %f",s ,s2[i*column_count+j].AsFloat);
      m.Set(i, j, s2[i*column_count+j].AsFloat);
    }
  }

  return m;
}

String Transform::get_AsString(){
  String s = "";

  for(int i=0; i<this.row_count; i++){
    s = s.Append("{");
    for(int j=0; j<this.column_count; j++){
      s = s.Append(String.Format("%f",this.Get(i, j)));
      if(j<this.column_count-1) s = s.Append(",");
    }
    if(i<this.row_count-1) s = s.Append("},[");
    else s = s.Append("}");
  }
  s = s.Append("");

  return s;
}

Transform* Transform::Clone() {
  Transform* m = new Transform;

  m.row_count = this.row_count;
  m.column_count = this.column_count;
  m.cell_count = this.cell_count;

  for(int i=0; i<m.cell_count; i++){
    m.v[i] = this.v[i];
  }

  return m;
}

bool Transform::isEqual(Transform* m){
  if(m.row_count != this.row_count) return false;
  if(m.column_count != this.column_count) return false;
  if(m.cell_count != this.cell_count) return false;
  for(int i=0; i<m.row_count; i++){
    for(int j=0; j<m.column_count; j++){
      if(m.Get(i, j)!=this.Get(i, j)) return false;
    }
  }
  return true;
}

Transform* Transform::Add(Transform* m){
  if(m.row_count == this.row_count && m.column_count == this.column_count){
    Transform* r = new Transform;
    r.row_count = m.row_count;
    r.column_count = m.column_count;
    r.cell_count = m.cell_count;

    for(int i=0; i<m.row_count; i++){
      for(int j=0; j<m.column_count; j++){
         r.Set(i, j, this.Get(i, j) + m.Get(i, j));
      }
    }

    return r;
  }
  return null;
}

Transform* Transform::Sub(Transform* m){
  if(m.row_count == this.row_count && m.column_count == this.column_count){
    Transform* r = new Transform;
    r.row_count = m.row_count;
    r.column_count = m.column_count;
    r.cell_count = m.cell_count;

    for(int i=0; i<m.row_count; i++){
      for(int j=0; j<m.column_count; j++){
         r.Set(i, j, this.Get(i, j) - m.Get(i, j));
      }
    }

    return r;
  }
  return null;
}

Transform* Transform::Mul(Transform* m){
  if(this.column_count == m.row_count){
    Transform* r = new Transform;
    r.row_count = this.row_count;
    r.column_count = m.column_count;
    r.cell_count = r.row_count*r.column_count;

    for(int i=0; i<r.row_count; i++){
      for(int j=0; j<r.column_count; j++){
        float cell=0.0;
        for(int k=0; k<m.row_count; k++){
          cell+=this.Get(i, k)*m.Get(k, j);
        }

        r.Set(i, j, cell);
      }
    }
    return r;
  }
  return null;
}

Transform* Transform::MulNum(float f) {
  Transform* r = this.Clone();

  for(int i=0; i<r.cell_count; i++){
    r.v[i] = r.v[i]*f;
  }
  return r;
}

Transform* Transform::DivNum(float f) {
  Transform* r = this.Clone();

  for(int i=0; i<r.cell_count; i++){
    r.v[i] = r.v[i]/f;
  }
  return r;
}

Transform* Transform::Pow(int n){
  if(this.row_count != this.column_count){
    return null;
  }

  Transform* m = this.Clone();
  for(int i=1; i<n; i++){
    m = m.Mul(m);
  }
  return m;
}

float Transform::MaxCell() {
  float r = this.v[0];

  for(int i=0; i<this.cell_count; i++){
    if(this.v[i]>r) r=this.v[i];
  }

  return r;
}

float Transform::MinCell() {
  float r = this.v[0];

  for(int i=0; i<this.cell_count; i++){
    if(this.v[i]<r) r=this.v[i];
  }

  return r;
}

float Transform::Determinant(){
  if(this.row_count != this.column_count){
    return 0.0;
  }

  if(this.row_count == 1) {
    return this.Get(0, 0);
  } else if(this.row_count == 2) {
    return (this.Get(0,0) * this.Get(1,1)) - (this.Get(0,1) * this.Get(1,0));
  } else if(this.row_count == 3) {
    float r=0.0;
    r = r + this.Get(0, 0) * (this.Get(1, 1) * this.Get(2, 2) - this.Get(2, 1) * this.Get(1, 2));
    r = r - this.Get(0, 1) * (this.Get(1, 0) * this.Get(2, 2) - this.Get(1, 2) * this.Get(2, 0));
    r = r + this.Get(0, 2) * (this.Get(1, 0) * this.Get(2, 1) - this.Get(1, 1) * this.Get(2, 0));
    return r;
  } else if(this.row_count == 4){
    float r=0.0;
    r = r + this.Get(0,3) * this.Get(1,2) * this.Get(2,1) * this.Get(3,0) - this.Get(0,2) * this.Get(1,3) * this.Get(2,1) * this.Get(3,0);
    r = r - this.Get(0,3) * this.Get(1,1) * this.Get(2,2) * this.Get(3,0) + this.Get(0,1) * this.Get(1,3) * this.Get(2,2) * this.Get(3,0);
    r = r + this.Get(0,2) * this.Get(1,1) * this.Get(2,3) * this.Get(3,0) - this.Get(0,1) * this.Get(1,2) * this.Get(2,3) * this.Get(3,0);
    r = r - this.Get(0,3) * this.Get(1,2) * this.Get(2,0) * this.Get(3,1) + this.Get(0,2) * this.Get(1,3) * this.Get(2,0) * this.Get(3,1);
    r = r + this.Get(0,3) * this.Get(1,0) * this.Get(2,2) * this.Get(3,1) - this.Get(0,0) * this.Get(1,3) * this.Get(2,2) * this.Get(3,1);
    r = r - this.Get(0,2) * this.Get(1,0) * this.Get(2,3) * this.Get(3,1) + this.Get(0,0) * this.Get(1,2) * this.Get(2,3) * this.Get(3,1);
    r = r + this.Get(0,3) * this.Get(1,1) * this.Get(2,0) * this.Get(3,2) - this.Get(0,1) * this.Get(1,3) * this.Get(2,0) * this.Get(3,2);
    r = r - this.Get(0,3) * this.Get(1,0) * this.Get(2,1) * this.Get(3,2) + this.Get(0,0) * this.Get(1,3) * this.Get(2,1) * this.Get(3,2);
    r = r + this.Get(0,1) * this.Get(1,0) * this.Get(2,3) * this.Get(3,2) - this.Get(0,0) * this.Get(1,1) * this.Get(2,3) * this.Get(3,2);
    r = r - this.Get(0,2) * this.Get(1,1) * this.Get(2,0) * this.Get(3,3) + this.Get(0,1) * this.Get(1,2) * this.Get(2,0) * this.Get(3,3);
    r = r + this.Get(0,2) * this.Get(1,0) * this.Get(2,1) * this.Get(3,3) - this.Get(0,0) * this.Get(1,2) * this.Get(2,1) * this.Get(3,3);
    r = r - this.Get(0,1) * this.Get(1,0) * this.Get(2,2) * this.Get(3,3) + this.Get(0,0) * this.Get(1,1) * this.Get(2,2) * this.Get(3,3);
    return r;
  } else {
    float determinant1, determinant2;
    for (int i = 0; i < this.row_count; i++) {
      float temp = 1.0;
      float temp2 = 1.0;
      for (int j = 0; j < this.column_count; j++) {
          temp *= this.Get((i + j) % this.column_count, j);
          temp2 *= this.Get((i + j) % this.column_count, this.row_count - 1 - j);
      }

      determinant1 += temp;
      determinant2 += temp2;
    }

    return determinant1 - determinant2;
  }
  return 0.0;
}

Quat* Transform::DoTransform(float px, float py, float pz, float pw){ 
  float x = px * this.Get(0,0) + py * this.Get(1,0) + pz * this.Get(2,0) + pw * this.Get(3,0);
  float y = px * this.Get(0,1) + py * this.Get(1,1) + pz * this.Get(2,1) + pw * this.Get(3,1);
  float z = px * this.Get(0,2) + py * this.Get(1,2) + pz * this.Get(2,2) + pw * this.Get(3,2);
  float w = px * this.Get(0,3) + py * this.Get(1,3) + pz * this.Get(2,3) + pw * this.Get(3,3);
  return Quat.Create(x, y, z, w);
}

Quat* Transform::DoTransformQuat(Quat* q){
  return this.DoTransform(q.x, q.y, q.z, q.w);
}

Transform* Transform::Invert44(){
  float inv[16];
  float m[16];
  float det;
  int i;
  
  for (i = 0; i < 16; i++) m[i] = this.v[i];
  
  inv[0] = m[5]  * m[10] * m[15] - 
         m[5]  * m[11] * m[14] - 
         m[9]  * m[6]  * m[15] + 
         m[9]  * m[7]  * m[14] +
         m[13] * m[6]  * m[11] - 
         m[13] * m[7]  * m[10];

  inv[4] = -m[4]  * m[10] * m[15] + 
            m[4]  * m[11] * m[14] + 
            m[8]  * m[6]  * m[15] - 
            m[8]  * m[7]  * m[14] - 
            m[12] * m[6]  * m[11] + 
            m[12] * m[7]  * m[10];

  inv[8] = m[4]  * m[9] * m[15] - 
           m[4]  * m[11] * m[13] - 
           m[8]  * m[5] * m[15] + 
           m[8]  * m[7] * m[13] + 
           m[12] * m[5] * m[11] - 
           m[12] * m[7] * m[9];

  inv[12] = -m[4]  * m[9] * m[14] + 
             m[4]  * m[10] * m[13] +
             m[8]  * m[5] * m[14] - 
             m[8]  * m[6] * m[13] - 
             m[12] * m[5] * m[10] + 
             m[12] * m[6] * m[9];

  inv[1] = -m[1]  * m[10] * m[15] + 
            m[1]  * m[11] * m[14] + 
            m[9]  * m[2] * m[15] - 
            m[9]  * m[3] * m[14] - 
            m[13] * m[2] * m[11] + 
            m[13] * m[3] * m[10];

  inv[5] = m[0]  * m[10] * m[15] - 
           m[0]  * m[11] * m[14] - 
           m[8]  * m[2] * m[15] + 
           m[8]  * m[3] * m[14] + 
           m[12] * m[2] * m[11] - 
           m[12] * m[3] * m[10];

  inv[9] = -m[0]  * m[9] * m[15] + 
            m[0]  * m[11] * m[13] + 
            m[8]  * m[1] * m[15] - 
            m[8]  * m[3] * m[13] - 
            m[12] * m[1] * m[11] + 
            m[12] * m[3] * m[9];

  inv[13] = m[0]  * m[9] * m[14] - 
            m[0]  * m[10] * m[13] - 
            m[8]  * m[1] * m[14] + 
            m[8]  * m[2] * m[13] + 
            m[12] * m[1] * m[10] - 
            m[12] * m[2] * m[9];

  inv[2] = m[1]  * m[6] * m[15] - 
           m[1]  * m[7] * m[14] - 
           m[5]  * m[2] * m[15] + 
           m[5]  * m[3] * m[14] + 
           m[13] * m[2] * m[7] - 
           m[13] * m[3] * m[6];

  inv[6] = -m[0]  * m[6] * m[15] + 
            m[0]  * m[7] * m[14] + 
            m[4]  * m[2] * m[15] - 
            m[4]  * m[3] * m[14] - 
            m[12] * m[2] * m[7] + 
            m[12] * m[3] * m[6];

  inv[10] = m[0]  * m[5] * m[15] - 
            m[0]  * m[7] * m[13] - 
            m[4]  * m[1] * m[15] + 
            m[4]  * m[3] * m[13] + 
            m[12] * m[1] * m[7] - 
            m[12] * m[3] * m[5];

  inv[14] = -m[0]  * m[5] * m[14] + 
             m[0]  * m[6] * m[13] + 
             m[4]  * m[1] * m[14] - 
             m[4]  * m[2] * m[13] - 
             m[12] * m[1] * m[6] + 
             m[12] * m[2] * m[5];

  inv[3] = -m[1] * m[6] * m[11] + 
            m[1] * m[7] * m[10] + 
            m[5] * m[2] * m[11] - 
            m[5] * m[3] * m[10] - 
            m[9] * m[2] * m[7] + 
            m[9] * m[3] * m[6];

  inv[7] = m[0] * m[6] * m[11] - 
           m[0] * m[7] * m[10] - 
           m[4] * m[2] * m[11] + 
           m[4] * m[3] * m[10] + 
           m[8] * m[2] * m[7] - 
           m[8] * m[3] * m[6];

  inv[11] = -m[0] * m[5] * m[11] + 
             m[0] * m[7] * m[9] + 
             m[4] * m[1] * m[11] - 
             m[4] * m[3] * m[9] - 
             m[8] * m[1] * m[7] + 
             m[8] * m[3] * m[5];

  inv[15] = m[0] * m[5] * m[10] - 
            m[0] * m[6] * m[9] - 
            m[4] * m[1] * m[10] + 
            m[4] * m[2] * m[9] + 
            m[8] * m[1] * m[6] - 
            m[8] * m[2] * m[5];
  
  det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];
  
  if (det == 0.0)
        return null;
        
  det = 1.0 / det;
  
  Transform* res = new Transform;

  res.row_count = 4;
  res.column_count = 4;
  res.cell_count = 16;
  
  for (i = 0; i < 16; i++)
        res.v[i] = inv[i] * det;
        
  return res;
}

Transform* Transform::SetIdentity(){
  Transform* m = this.Clone();
  
  for(int i=0; i<m.row_count; i++){
    for(int j=0; j<m.column_count; j++){
      if(i==j){
        m.Set(i, j, 1.0);
      } else {
        m.Set(i, j, 0.0);
      }
    }
  }
  
  return m;
}

Transform* Transform::SetTranslate(float x, float y, float z){
  Transform* m = this.Clone();
  
  m.Set(3, 0, x);
  m.Set(3, 1, y);
  m.Set(3, 2, z);
  
  return m;
}

Transform* Transform::SetScale(float x, float y, float z){
  Transform* m = this.Clone();
  
  m.Set(0, 0, x);
  m.Set(1, 1, y);
  m.Set(2, 2, z);
  
  return m;
}

Transform* Transform::SetRotateEuler(float x, float y, float z){
  Transform* m = this.Clone();
  
  r1.Set(0, 0, 1.0 );
  r1.Set(0, 1, 0.0 );
  r1.Set(0, 2, 0.0 );
  r1.Set(1, 0, 0.0 );
  r1.Set(1, 1, Maths.Cos(x) );
  r1.Set(1, 2, -Maths.Sin(x) );
  r1.Set(2, 0, 0.0 );
  r1.Set(2, 1, Maths.Sin(x) );
  r1.Set(2, 2, Maths.Cos(x) );
  
  r2.Set(0, 0, Maths.Cos(y) );
  r2.Set(0, 1,  0.0 );
  r2.Set(0, 2, Maths.Sin(y) );
  r2.Set(1, 0,  0.0 );
  r2.Set(1, 1,  1.0 );
  r2.Set(1, 2,  0.0 );
  r2.Set(2, 0, -Maths.Sin(y) );
  r2.Set(2, 1,  0.0 );
  r2.Set(2, 2, Maths.Cos(y) );
  
  r3.Set(0, 0, Maths.Cos(z) );
  r3.Set(0, 1, -Maths.Sin(z) );
  r3.Set(0, 2, 0.0 );
  r3.Set(1, 0, Maths.Sin(z) );
  r3.Set(1, 1, Maths.Cos(z) );
  r3.Set(1, 2, 0.0 );
  r3.Set(2, 0, 0.0 );
  r3.Set(2, 1, 0.0 );
  r3.Set(2, 2, 1.0 );
  
  Matrix* rR_1x2 = r1.Mul(r2); 
  Matrix* rR = rR_1x2.Mul(r3); 

  for(int i=0; i<2; i++){
    for(int j=0; j<2; j++){
       m.Set(i, j, rR.Get(i, j));
    }
  }

  m.Set(0, 3, 0.0 );
  m.Set(1, 3, 0.0 );
  m.Set(2, 3, 0.0 );
  m.Set(3, 0, 0.0 );
  m.Set(3, 1, 0.0 );
  m.Set(3, 2, 0.0 );
  m.Set(3, 3, 1.0 );
  
  return m;
}

Transform* Transform::SetFullTransform(float x, float y, float z, float sx, float sy, float sz, float rx, float ry, float rz){
  tT = tT.SetTranslate(x, y, z);
  tS = tS.SetScale(sx, sy, sz);
  tR = tR.SetRotateEuler(rx, ry, rz);
  
  Transform* t1 = tR.Mul(tS);
  t1 = t1.Mul(tT);
  
  return t1;  
}

Transform* Transform::SetOrthographicProjection(float left, float right, float bottom, float top, float near, float far){
  Transform* m = this.Clone();
  
  for(int i=0; i<m.row_count; i++){
    for(int j=0; j<m.column_count; j++){
      m.Set(i, j, 0.0);
    }
  }
  
  m.Set(0, 0, 2.0 / (right - left) );
  m.Set(1, 1, 2.0 / (top - bottom) );
  m.Set(2, 2, -(2.0 / (far - near)) );
  m.Set(3, 0, -(right + left) / (right - left) );
  m.Set(3, 1, -(top + bottom) / (top - bottom) );
  m.Set(3, 2, -(far + near) / (far - near) );
  m.Set(3, 3, -1.0 );

  return m;
}

Transform* Transform::SetPerspectiveProjection(float fovx, float fovy, float near, float far){
  Transform* m = this.Clone();
  
  for(int i=0; i<m.row_count; i++){
    for(int j=0; j<m.column_count; j++){
      m.Set(i, j, 0.0);
    }
  }
  
  m.Set(0, 0, 1.0 / Maths.Tan(fovx / 2.0) );
  m.Set(1, 1, 1.0 / Maths.Tan(fovy / 2.0) );
  m.Set(2, 2, -(far / (far - near)) );
  m.Set(2, 3, -1.0 );
  m.Set(3, 2, -((far * near) / (far - near)) );

  return m;
}


void game_start() {
  r1 = Matrix.Create(3, 3, eMT_Identity);
  r2 = Matrix.Create(3, 3, eMT_Identity);
  r3 = Matrix.Create(3, 3, eMT_Identity);
  
  tT = Transform.Create();
  tS = Transform.Create();
  tR = Transform.Create();
}